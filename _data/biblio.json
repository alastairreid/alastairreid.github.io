[
    {
        "primaryclass": "cs.LO",
        "archiveprefix": "arXiv",
        "eprint": "2010.16345",
        "url": "https://research.google/pubs/pub49713/",
        "ar_shortname": "HATRA 20",
        "note": "Accepted at HATRA 2020",
        "day": "30",
        "month": "October",
        "year": "2020",
        "abstract": "Formal verification of software is a bit of a niche\nactivity: it is only applied to the most safety-critical or\nsecurity-critical software and it is typically only performed by\nspecialized verification engineers. This paper considers whether\nit would be possible to increase adoption of formal methods by\nintegrating formal methods with developers\\textquotesingle  existing practices\nand workflows.\n\nWe do not believe that widespread adoption will follow from\nmaking the prevailing formal methods argument that correctness\nis more important than engineering teams realize. Instead, our\nfocus is on what we would need to do to enable programmers to\nmake effective use of formal verification tools and techniques.\nWe do this by considering how we might make verification tooling\nthat both serves developers\\textquotesingle  needs and fits into their existing\ndevelopment lifecycle. We propose a target of two orders of\nmagnitude increase in adoption within a decade driven by\nensuring a positive \\textasciigrave weekly cost-benefit\\textquotesingle  ratio for developer\ntime invested.",
        "author": "Alastair Reid and\nLuke Church and\nShaked Flur and\nSarah de Haas and\nMaritza Johnson and\nBen Laurie",
        "title": "{T}owards making formal methods normal: meeting developers where they are",
        "ENTRYTYPE": "misc",
        "ID": "reid:hatra:2020",
        "link": "https://research.google/pubs/pub49713/",
        "file": "hatra2020.pdf",
        "png": "hatra2020.png",
        "ar_file": "HATRA_20",
        "ar_title": "Towards making formal methods normal: meeting developers where they are"
    },
    {
        "month": "September",
        "year": "2019",
        "ar_shortname": "SpISA 19",
        "location": "Portland, Oregon, USA",
        "booktitle": "SpISA 2019: Workshop on Instruction Set Architecture Specification",
        "abstract": "\n\nSail is a custom domain-specific language for ISA semantics, in which we have\ndeveloped formal models for ARMv8-A, RISC-V, and MIPS, as well as CHERI-based\ncapability extensions for both RISC-V and MIPS. In particular, our model of\nARMv8-A is automatically translated from ARM-internal definitions and tested\nagainst the ARM Architecture validation suite. All the above models contain\nenough system-level features to boot various operating systems, including Linux\nand FreeBSD, but also various smaller microkernels and hypervisors.\n\nIn this short paper, we present the ways in which Sail enables us to bridge the\ngap between our various ISA models and the myriad use cases for such models. By\nusing Sail, we are able to generate emulators for testing and validation,\ngenerate theorem prover definitions across multiple major tools (Isabelle,\nHOL4, and Coq), translate Sail to SMT for automatic verification, and integrate\nwith both operational models for relaxed-memory concurrency via our RMEM tool.\n\nWe will also present our current work to extend Sail to support axiomatic\nconcurrency models, in the style of Alglave and Maranget\u2019s herd7 tool, with the\nintent being to explore the behaviour of concurrent litmus tests that span the\nfull behaviour of the architecture. As an illustrative example, one could\nconsider how instruction cache maintenance instructions interact with\nself-modifying code in an axiomatic setting, or other interesting cases that\nare not well-covered by existing tools\n",
        "author": "Alasdair Armstrong and\nThomas Bauereiss and\nBrian Campbell and\nAlastair Reid and\nKathryn E. Gray and\nRobert Norton and\nPrashanth Mundkur and\nMark Wassell and\nJon French and\nChristopher Pulte and\nShaked Flur and\nIan Stark and\nNeel Krishnaswami and\nPeter Sewell",
        "title": "{T}he {S}tate of {S}ail",
        "ENTRYTYPE": "article",
        "ID": "conf/spisa19/armstrong",
        "file": "spisa2019.pdf",
        "png": "spisa2019.png",
        "ar_file": "SpISA_19",
        "ar_title": "The State of Sail"
    },
    {
        "year": "2019",
        "month": "March",
        "ar_shortname": "PhD 19",
        "numpages": "161",
        "location": "Glasgow, Scotland",
        "abstract": "One of the most important interfaces in a computer system is the interface\nbetween hardware and software.  This interface is the contract between the\nhardware designer and the programmer that defines the functional behaviour of\nthe hardware.  This thesis examines two critical aspects of defining the\nhardware-software interface: quality and performance.\n\nThe first aspect is creating a high quality specification of the interface as\nconventionally defined in an instruction set architecture.  The majority of\nthis thesis is concerned with creating a specification that covers the full\nscope of the interface; that is applicable to all current implementations of\nthe architecture; and that can be trusted to accurately describe the behaviour\nof implementations of the architecture.  We describe the development of\na formal specification of the two major types of Arm processors: A-class (for\nmobile devices such as phones and tablets) and M-class (for micro-controllers).\nThese specifications are unparalleled in their scope, applicability and\ntrustworthiness.  This thesis identifies and illustrates what we consider the\nkey ingredient in achieving this goal: creating a specification that is used by\nmany different user groups.  Supporting many different groups leads to improved\nquality as each group finds different problems in the specification; and, by\nproviding value to each different group, it helps justify the considerable\neffort required to create a high quality specification of a major processor\narchitecture.  The work described in this thesis led to a step change in Arm\\textquotesingle s\nability to use formal verification techniques to detect errors in their\nprocessors; enabled extensive testing of the specification against Arm\\textquotesingle s\nofficial architecture conformance suite; improved the quality of Arm\\textquotesingle s\narchitecture conformance suite based on measuring the architectural coverage of\nthe tests; supported earlier, faster development of architecture extensions by\nenabling animation of changes as they are being made; and enabled early\ndetection of problems created from architecture extensions by performing formal\nvalidation of the specification against semi-structured natural language\nspecifications.  As far as we are aware, no other mainstream processor\narchitecture has this capability.  The formal specifications are included in\nArm\\textquotesingle s publicly released architecture reference manuals and the A-class\nspecification is also released in machine-readable form.\n\nThe second aspect is creating a high performance interface by defining the\nhardware-software interface of a software-defined radio subsystem using\na programming language.  That is, an interface that allows software to exploit\nthe potential performance of the underlying hardware.  While the\nhardware-software interface is normally defined in terms of machine code,\nperipheral control registers and memory maps, we define it using a programming\nlanguage instead.  This higher level interface provides the opportunity for\ncompilers to hide some of the low-level differences between different systems\nfrom the programmer: a potentially very efficient way of providing a stable,\nportable interface without having to add hardware to provide portability\nbetween different hardware platforms.  We describe the design and\nimplementation of a set of extensions to the C programming language to support\nprogramming high performance, energy efficient, software defined radio systems.\nThe language extensions enable the programmer to exploit the pipeline\nparallelism typically present in digital signal processing applications and to\nmake efficient use of the asymmetric multiprocessor systems designed to support\nsuch applications.  The extensions consist primarily of annotations that can be\nchecked for consistency and that support annotation inference in order to\nreduce the number of annotations required.  Reducing the number of annotations\ndoes not just save programmer effort, it also improves portability by reducing\nthe number of annotations that need to be changed when porting an application\nfrom one platform to another.  This work formed part of a project that\ndeveloped a high-performance, energy-efficient, software defined radio capable\nof implementing the physical layers of the 4G cellphone standard (LTE), 802.11a\nWiFi and Digital Video Broadcast (DVB) with a power and silicon area budget\nthat was competitive with a conventional custom ASIC solution.\n\nThe Arm architecture is the largest computer architecture by volume in the\nworld.  It behooves us to ensure that the interface it describes is\nappropriately defined.\n",
        "school": "School of Computing Science, University of Glasgow",
        "affiliation": "School of Computing Science, University of Glasgow",
        "title": "{D}efining interfaces between hardware and software: {Q}uality and performance",
        "author": "Alastair Reid",
        "ENTRYTYPE": "phdthesis",
        "ID": "ReidPhDThesis2019",
        "file": "2019reidphd.pdf",
        "png": "2019reidphd.png",
        "ar_file": "PhD_19",
        "ar_title": "Defining interfaces between hardware and software: Quality and performance"
    },
    {
        "address": "New York, NY, USA",
        "publisher": "ACM",
        "numpages": "31",
        "location": "Cascais/Lisbon, Portugal",
        "ar_shortname": "POPL 19",
        "abstract": "Architecture specifications notionally define the fundamental\ninterface between hardware and software: the envelope of\nallowed behaviour for processor implementations, and the basic\nassumptions for software development and verification.  But in\npractice, they are typically prose and pseudocode documents,\nnot rigorous or executable artifacts, leaving software and\nverification on shaky ground.\n\nIn this paper, we present rigorous semantic models for the sequential behaviour\nof large parts of the mainstream ARMv8-A, RISC-V, and MIPS architectures, and\nthe research CHERI-MIPS architecture, that are complete enough to boot\noperating systems, variously Linux, FreeBSD, or seL4.  Our ARMv8-A models are\nautomatically translated from authoritative ARM-internal definitions, and (in\none variant) tested against the ARM Architecture Validation Suite.\n\nWe do this using a custom language for ISA semantics, Sail, with a lightweight\ndependent type system, that supports automatic generation of emulator code in\nC and OCaml, and automatic generation of proof-assistant definitions for\nIsabelle, HOL4, and (currently only for MIPS) Coq.  We use the former for\nvalidation, and to assess specification coverage.  To demonstrate the usability\nof the latter, we prove (in Isabelle) correctness of a purely functional\ncharacterisation of ARMv8-A address translation.  We moreover integrate the\nRISC-V model into the RMEM tool for (user-mode) relaxed-memory concurrency\nexploration.  We prove (on paper) the soundness of the core Sail type system.\n\nWe thereby take a big step towards making the architectural abstraction\nactually well-defined, establishing foundations for verification and reasoning.\n",
        "doi": "10.1145/3290384",
        "day": "13-19",
        "month": "January",
        "year": "2019",
        "pages": "71:1--71:31",
        "booktitle": "Proc. 46th ACM SIGPLAN Symposium on Principles of Programming Languages",
        "number": "POPL",
        "volume": "3",
        "journal": "PACMPL",
        "author": "\nAlasdair Armstrong and\nThomas Bauereiss and\nBrian Campbell and\nAlastair Reid and\nKathryn E. Gray and\nRobert M. Norton and\nPrashanth Mundkur and\nMark Wassell and\nJon French and\nChristopher Pulte and\nShaked Flur and\nIan Stark and\nNeel Krishnaswami and\nPeter Sewell\n",
        "title": "I{S}A {S}emantics for {A}RMv8-{A}, {R}IS{C}-V, and {C}HE{R}I-{M}IP{S}",
        "ENTRYTYPE": "inproceedings",
        "ID": "conf/popl19/armstrong",
        "file": "popl19-isasemantics.pdf",
        "png": "popl19-isasemantics.png",
        "ar_file": "POPL_19",
        "ar_title": "ISA Semantics for ARMv8-A, RISC-V, and CHERI-MIPS"
    },
    {
        "month": "April",
        "year": "2018",
        "ar_shortname": "ARW 18",
        "location": "Cambridge, UK",
        "booktitle": "Automated Reasoning Workshop 2018",
        "abstract": "Processor instruction set architectures (ISAs) are typically\nspecified using a mixture of prose and pseudocode. We present\nongoing work on expressing such specifications rigorously and\nautomatically trans- lating them to interactive theorem prover\ndefinitions, making them amenable to mechanised proof. Our ISA\ndescriptions are written in Sail\\textemdash a custom ISA specification\nlanguage designed to support idioms from var- ious processor\nvendor\u2019s pseudocode, with lightweight dependent typing for\nbitvectors, targeting a variety of use cases including\nsequential and concurrent ISA semantics. From Sail we aim to\nportably generate usable theorem prover definitions for\nmultiple provers, including Isabelle, HOL4, and Coq. We are\nfocusing on the full ARMv8.3-A specification, CHERI-MIPS, and\nRISC-V, together with fragments of IBM POWER and x86.\n",
        "authors": "Alasdair Armstrong\nand Thomas Bauereiss\nand Brian Campbell\nand Shaked Flur\nand Kathryn E. Gray\nand Prashanth Mundkur\nand Robert Norton\nand Christopher Pulte\nand Alastair Reid\nand Peter Sewell\nand Ian Stark\nand Mark Wassell",
        "title": "{D}etailed {M}odels of {I}nstruction {S}et {A}rchitectures: {F}rom {P}seudocode to {F}ormal {S}emantics",
        "ENTRYTYPE": "article",
        "ID": "conf/arw18/armstrong",
        "file": "arw2018.pdf",
        "png": "arw2018.png",
        "ar_file": "ARW_18",
        "ar_title": "Detailed Models of Instruction Set Architectures: From Pseudocode to Formal Semantics"
    },
    {
        "address": "New York, NY, USA",
        "publisher": "ACM",
        "numpages": "24",
        "location": "Vancouver, BC, Canada",
        "ar_shortname": "OOPSLA 17",
        "doi": "10.1145/3133912",
        "day": "22\\textendash 27",
        "month": "October",
        "year": "2017",
        "pages": "88:1--88:24",
        "number": "OOPSLA",
        "volume": "1",
        "journal": "PACMPL",
        "abstract": "\nSoftware and hardware are increasingly being formally verified\nagainst specifications, but how can we verify the\nspecifications themselves? This talk explores what it means to\nformally verify a specification. We solve three challenges: (1)\nHow to create a secondary, higher-level specification that can\nbe effectively reviewed by processor designers who are not\nexperts in formal verification; (2) How to avoid common-mode\nfailures between the specifications; and (3) How to\nautomatically verify the two specifications against each other.\n\nOne of the most important specifications for software\nverification is the processor specification since it de nes the\nbehaviour of machine code and of hardware protection features\nused by operating systems. We demonstrate our approach on ARM\\textquotesingle s\nv8-M Processor Specification, which is intended to improve the\nsecurity of Internet of Things devices. Thus, we focus on\nestablishing the security guarantees the architecture is\nintended to provide. Despite the fact that the ARM v8-M\nspecification had previously been extensively tested, we found\ntwelve bugs (including two security bugs) that have all been\nfixed by ARM.\n",
        "affiliation": "ARM Ltd",
        "authors": "Alastair Reid",
        "title": "{W}ho guards the guards? {F}ormal {V}alidation of the {A}RM v8-{M} Architecture {S}pecification",
        "ENTRYTYPE": "inproceedings",
        "ID": "conf/oopsla/Reid17",
        "file": "oopsla2017-whoguardstheguards.pdf",
        "png": "oopsla2017-whoguardstheguards.png",
        "slides": "oopsla2017-whoguardstheguards-slides.pdf",
        "ar_file": "OOPSLA_17",
        "ar_title": "Who guards the guards? Formal Validation of the ARM v8-M Architecture Specification"
    },
    {
        "primaryclass": "cs.AR",
        "archiveprefix": "arXiv",
        "eprint": "1803.06185",
        "ar_shortname": "IEEE Micro",
        "doi": "10.1109/MM.2017.35",
        "pages": "26--39",
        "number": "2",
        "volume": "37",
        "year": "2017",
        "month": "March",
        "journal": "IEEE Micro",
        "abstract": "\nIn this paper we describe the ARM Scalable Vector Extension\n(SVE). Several goals guided the design of the architecture. First was\nthe need to extend the vector processing capability associated with\nthe ARM AArch64 execution state to better address the compute\nrequirements in domains such as high performance computing (HPC), data\nanalytics, computer vision and machine learning. Second was the desire\nto introduce an extension that can scale across multiple\nimplementations, both now and into the future, allowing CPU designers\nto choose the vector length most suitable for their power, performance\nand area targets. Finally, the architecture should avoid imposing a\nsoftware development cost as the vector length changes and where\npossible reduce it by improving the reach of compiler\nauto-vectorization technologies.\n\nWe believe SVE achieves these goals. It allows implementations to\nchoose a vector register length between 128 and 2048 bits. It supports\na vector length agnostic programming model which allows code to run\nand scale automatically across all vector lengths without\nrecompilation. Finally, it introduces several innovative features that\nbegin to overcome some of the traditional barriers to\nauto-vectorization.\n",
        "affiliation": "ARM Ltd",
        "authors": "\nNigel Stephens\nand\nStuart Biles\nand\nMatthias Boettcher\nand\nJacob Eapen\nand\nMbou Eyole\nand\nGiacomo Gabrielli\nand\nMatt Horsnell\nand\nGrigorios Magklis\nand\nAlejandro Martinez\nand\nNathanael Premillieu\nand\nAlastair Reid\nand\nAlejandro Rico\nand\nPaul Walker\n",
        "title": "{T}he {A}RM {S}calable {V}ector {E}xtension",
        "ENTRYTYPE": "article",
        "ID": "journal/micro/sve2017",
        "file": "sve-ieee-micro-2017.pdf",
        "png": "sve-ieee-micro-2017.png",
        "ar_file": "IEEE_Micro",
        "ar_title": "The ARM Scalable Vector Extension"
    },
    {
        "url": "https://alastairreid.github.io/papers/fmcad2016-trustworthy.pdf",
        "ar_shortname": "FMCAD 16",
        "isbn": "978-0-9835678-6-8",
        "year": "2016",
        "month": "October",
        "pages": "161-168",
        "location": "Mountain View, CA, USA",
        "booktitle": "Proceedings of Formal Methods in Computer-Aided Design\n(FMCAD 2016)",
        "abstract": "\nProcessor specifications are of critical importance for verifying programs,\ncompilers, operating systems/hypervisors, and, of course, for verifying\nmicroprocessors themselves.  But to be useful, the scope of these\nspecifications must be sufficient for the task, the specification must be\napplicable to processors of interest and the specification must be trustworthy.\n\nThis paper describes a 5 year project to change ARM\\textquotesingle s existing architecture\nspecification process so that machine-readable, executable specifications can\nbe automatically generated from the same materials used to generate ARM\\textquotesingle s\nconventional architecture documentation.  We have developed executable\nspecifications of both ARM\\textquotesingle s A-class and M-class processor architectures that\nare complete enough and trustworthy enough that we have used them to formally\nverify ARM processors using bounded model checking.  In particular, our\nspecifications include the semantics of the most security sensitive parts of\nthe processor: the memory and register protection mechanisms and the exception\nmechanisms that trigger transitions between different modes.  Most importantly,\nwe have applied a diverse set of methods including ARM\\textquotesingle s internal processor\ntest suites to improve our trust in the specification using many other\nexpressions of the architectural specification such as ARM\\textquotesingle s simulators,\ntestsuites and processors to defend against common-mode failure.  In the\nprocess, we have also found bugs in all those artifacts: testing specifications\nis very much a two-way street.\n\nWhile there have been previous specifications of ARM processors, their scope\nhas excluded the system architecture, their applicability has excluded newer\nprocessors and M-class, and their trustworthiness has not been established as\nthoroughly.\n\nOur focus has been on enabling the formal verification of ARM processors but,\nrecognising the value of this specification for verifying software, we are\ncurrently preparing a public release of the machine-readable specification.\n",
        "affiliation": "ARM Ltd",
        "authors": "Alastair Reid",
        "title": "{T}rustworthy {S}pecifications of {A}RM v8-{A} and v8-{M}\nSystem {L}evel {A}rchitecture",
        "ENTRYTYPE": "inproceedings",
        "ID": "conf/fmcad/Reid16",
        "link": "https://alastairreid.github.io/papers/fmcad2016-trustworthy.pdf",
        "file": "fmcad2016-trustworthy.pdf",
        "png": "fmcad2016-trustworthy.png",
        "slides": "fmcad2016-trustworthy-slides.pdf",
        "ar_file": "FMCAD_16",
        "ar_title": "Trustworthy Specifications of ARM v8-A and v8-M System Level Architecture"
    },
    {
        "isbn": "978-3-319-41539-0",
        "ar_shortname": "CAV 16",
        "doi": "10.1007/978-3-319-41540-6\\_3",
        "number": "9780",
        "location": "Toronto, Canada",
        "journal": "CAV 2016, Part II, Lecture Notes in Computer Science",
        "authors": "Alastair Reid and Rick Chen and Anastasios Deligiannis and\nDavid Gilday and David Hoyes and Will Keen and Ashan Pathirane and\nErin Shepherd and Peter Vrabel and Ali Zaidi",
        "year": "2016",
        "month": "July",
        "publisher": "Springer Verlag",
        "pages": "42-58",
        "volume": "9780",
        "series": "Lecture Notes in Computer Science",
        "editor": "S. Chaudhuri and A. Farzan",
        "acceptance": "28",
        "abstract": "\nDespite 20+ years of research on processor verification, it remains hard to use\nformal verification techniques in commercial processor development.  There are\ntwo significant factors: scaling issues and return on investment.  The\nscaling issues include the size of modern processor specifications, the\nsize/complexity of processor designs, the size of design/verification teams and\nthe (non)availability of enough formal verification experts.  The return on\ninvestment issues include the need to start catching bugs early in development,\nthe need to continue catching bugs throughout development, and the need to be\nable to reuse verification IP, tools and techniques across a wide range of\ndesign styles.\n\nThis paper describes how ARM has overcome these issues in our Instruction Set\nArchitecture Formal Verification framework \\textasciigrave \\textasciigrave ISA-Formal.\\textquotesingle \\textquotesingle  This is an\nend-to-end framework to detect bugs in the datapath, pipeline control and\nforwarding/stall logic of processors.  A key part of making the approach scale\nis use of a mechanical translation of ARM\\textquotesingle s Architecture Reference Manuals to\nVerilog allowing the use of commercial model-checkers.  ISA-Formal has proven\nespecially effective at finding micro-architecture specific bugs involving\ncomplex sequences of instructions.\n\nAn essential feature of our work is that it is able to scale all the way from\nsimple 3-stage microcontrollers, through superscalar in-order processors up to\nout-of-order processors.  We have applied this method to 8 different ARM\nprocessors spanning all stages of development up to release.  In all\nprocessors, this has found bugs that would have been hard for conventional\nsimulation-based verification to find and ISA-Formal is now a key part of ARM\\textquotesingle s\nformal verification strategy.\n\nTo the best of our knowledge, this is the most broadly applicable formal\nverification technique for verifying processor pipeline control in mainstream\ncommercial use.\n",
        "affiliation": "ARM Ltd",
        "booktitle": "Proceedings of the 2016 International Conference on Computer Aided Verification (CAV\\textquotesingle 16)",
        "title": "{E}nd-to-{E}nd {V}erification of {A}RM {P}rocessors with {I}SA-{F}ormal",
        "ENTRYTYPE": "inproceedings",
        "ID": "conf/cav/Reid16",
        "file": "cav2016_isa_formal.pdf",
        "png": "cav2016_isa_formal.png",
        "slides": "cav2016_isa_formal-slides.pdf",
        "ar_file": "CAV_16",
        "ar_title": "End-to-End Verification of ARM Processors with ISA-Formal"
    },
    {
        "ar_shortname": "DATE 14",
        "doi": "10.7873/DATE.2014.037",
        "year": "2014",
        "month": "March",
        "day": "24-28",
        "publisher": "European Design and Automation Association",
        "pages": "1-4",
        "location": "Dresden, Germany",
        "booktitle": "Design, Automation \\& Test in Europe Conference \\& Exhibition\n(DATE 2014)",
        "acceptance": "22",
        "title": "{A}dvanced {S}IM{D}: {E}xtending the reach of contemporary {S}IM{D} architectures",
        "editor": "Gerhard Fettweis and\nWolfgang Nebel",
        "abstract": "\nSIMD extensions have gained widespread acceptance in modern\nmicroprocessors as a way to exploit data-level parallelism in\ngeneral-purpose cores. Popular SIMD architectures (e.g., Intel\nSSE/AVX) have evolved by adding support for wider registers and\ndatapaths, and advanced features like indexed memory\naccesses, per-lane predication and inter-lane instructions, at\nthe cost of additional silicon area and design complexity.\n\nThis paper evaluates the performance impact of such advanced\nfeatures on a set of workloads considered hard to vectorize for\ntraditional SIMD architectures. Their sensitivity to the most\nrelevant design parameters (e.g. register/datapath width and L1\ndata cache configuration) is quantified and discussed.\n\nWe developed an ARMv7 NEON based ISA extension (ARGON),\naugmented a cycle accurate simulation framework for it, and\nderived a set of benchmarks from the Berkeley dwarfs. Our\nanalyses demonstrate how ARGON can, depending on the structure\nof an algorithm, achieve speedups of 1.5x to 16x.\n",
        "affiliation": "ARM Ltd and University of Southampton",
        "author": "Matthias Boettcher and\nBashir M. Al-Hashimi and\nMbou Eyole and\nGiacomo Gabrielli and\nAlastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/date/BoettcherAEGR14",
        "file": "date2014_adv_simd.pdf",
        "png": "date2014_adv_simd.png",
        "ar_file": "DATE_14",
        "ar_title": "Advanced SIMD: Extending the reach of contemporary SIMD architectures"
    },
    {
        "ar_shortname": "CASES 08",
        "doi": "10.1145/1450095.1450112",
        "year": "2008",
        "month": "October",
        "day": "19-24",
        "publisher": "ACM",
        "pages": "95--104",
        "location": "Atlanta, GA, USA",
        "booktitle": "Proceedings of the 2008 International Conference on Compilers, Architecture,\nand Synthesis for Embedded Systems (CASES 2008)",
        "acceptance": "33",
        "editor": "Erik R. Altman",
        "abstract": "\nThe architectures of system-on-chip (SoC) platforms found in high-end\nconsumer devices are getting more and more complex as designers strive\nto deliver increasingly compute-intensive applications on\nnear-constant energy budgets.  Workloads running on these platforms\nrequire the exploitation of heterogeneous parallelism and increasingly\nirregular memory hierarchies.  The conventional approach to\nprogramming such hardware is very low-level but this yields software\nwhich is intimately and inseparably tied to the details of the\nplatform it was originally designed for, limiting the software\\textquotesingle s\nportability, and, ultimately, the architectural choices available to\ndesigners of future platform generations.  The key insight of this\npaper is that many of the problems experienced in mapping applications\nonto SoC platforms come not from deciding how to map a program onto\nthe hardware but from the need to restructure the program and the\nnumber of interdependencies introduced in the process of implementing\nthose decisions.  We tackle this complexity with a set of language\nextensions which allows the programmer to introduce pipeline\nparallelism into sequential programs, manage distributed memories, and\nexpress the desired mapping of tasks to resources.  The compiler takes\ncare of the complex, error-prone details required to implement that\nmapping.  We demonstrate the effectiveness of SoC-C and its compiler\nwith a \\textasciigrave \\textasciigrave software defined radio\\textquotesingle \\textquotesingle  example (the PHY layer of a Digital\nVideo Broadcast receiver) achieving a 3.4x speedup on 4 cores.\n",
        "affiliation": "ARM Ltd and University of Michigan",
        "title": "{S}oC-{C}: efficient programming abstractions for heterogeneous multicore\nsystems on chip",
        "author": "Alastair D. Reid and\nKriszti{\\'a}n Flautner and\nEdmund Grimley-Evans and\nYuan Lin",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/cases/ReidFGL08",
        "file": "cases2008-SoC-C.pdf",
        "png": "cases2008-SoC-C.png",
        "slides": "cases2008-SoC-C-slides.pdf",
        "ar_file": "CASES_08",
        "ar_title": "SoC-C: efficient programming abstractions for heterogeneous multicore systems on chip"
    },
    {
        "ar_shortname": "MICRO 08",
        "doi": "10.1109/MICRO.2008.4771787",
        "year": "2008",
        "publisher": "IEEE Computer Society",
        "pages": "152--163",
        "location": "Lake Como, Italy",
        "day": "8-12",
        "month": "November",
        "booktitle": "41st Annual IEEE/ACM International Symposium on Microarchitecture\n(MICRO-41 2008)",
        "acceptance": "19",
        "abstract": "\nWith the multitude of existing and upcoming wireless standards, it is becoming\nincreasingly difficult for hardware-only baseband processing solutions to adapt\nto the rapidly changing wireless communication landscape. Software Defined\nRadio (SDR) promises to deliver a cost effective and flexible solution by\nimplementing a wide variety of wireless protocols in software. In previous\nwork, a fully programmable multicore architecture, SODA, was proposed that was\nable to meet the real-time requirements of 3G wireless protocols. SODA consists\nof one ARM control processor and four wide single instruction multiple data\n(SIMD) processing elements. Each processing element consists of a scalar and\na wide 512-bit 32-lane SIMD datapath. A commercial prototype based on the SODA\narchitecture, Ardbeg (named after a brand of Scotch Whisky), has been\ndeveloped. In this paper, we present the architectural evolution of going from\na research design to a commercial prototype, including the goals, trade-offs,\nand final design choices.\n\nArdbeg\\textquotesingle s redesign process can be grouped into the following three major areas:\noptimizing the wide SIMD datapath, providing long instruction word (LIW)\nsupport for SIMD operations, and adding application-specific hardware\naccelerators. Because SODA was originally designed with 180nm technology, the\nwide SIMD datapath is re-optimized in Ardbeg for 90nm technology. This includes\nre-evaluating the most efficient SIMD width, designing a wider SIMD shuffle\nnetwork, and implementing faster SIMD arithmetic units. Ardbeg also provides\nmodest LIW support by allowing two SIMD operations to issue in the same cycle.\nThis LIW execution supports SDR algorithms\\textquotesingle  most common parallel SIMD execution\npatterns with minimal hardware overhead. A viable commercial SDR solution must\nbe competitive with existing ASIC solutions. Therefore, algorithm-specific\nhardware is added for performance bottleneck algorithms while still maintaining\nenough flexibility to support multiple wireless protocols. The combination of\nthese architectural improvements allows Ardbeg to achieve 1.5-7x speedup over\nSODA across multiple wireless algorithms while consuming less power.\n",
        "affiliation": "ARM Ltd and University of Michigan and Arizona State University",
        "title": "{F}rom {S}OD{A} to scotch: {T}he evolution of a wireless baseband processor",
        "author": "Mark Woh and\nYuan Lin and\nSangwon Seo and\nScott A. Mahlke and\nTrevor N. Mudge and\nChaitali Chakrabarti and\nRichard Bruce and\nDanny Kershaw and\nAlastair Reid and\nMladen Wilder and\nKriszti{\\'a}n Flautner",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/micro/WohLSMMCBKRWF08",
        "file": "mwoh-micro08.pdf",
        "png": "mwoh-micro08.png",
        "ar_file": "MICRO_08",
        "ar_title": "From SODA to scotch: The evolution of a wireless baseband processor"
    },
    {
        "ar_shortname": "SBAC-PAD 07",
        "doi": "10.1109/SBAC-PAD.2007.15",
        "year": "2007",
        "publisher": "IEEE Computer Society",
        "pages": "37--44",
        "location": "Gramado, RS, Brazil",
        "month": "October",
        "day": "24-27",
        "booktitle": "19th Symposium on Computer Architecture and High Performance Computing\n(SBAC-PAD 2007)",
        "abstract": "\nIn this paper, we propose two low-cost and novel branch history\nbuffer handling schemes aiming at skewing the branch prediction\naccuracy in favor of a real-time thread for a soft real-time\nembedded multithreaded processor. The processor core accommodates\ntwo running threads, one with the highest priority and the other\nthread is a background thread, and both threads share the branch\npredictor. The first scheme uses a 3-bit branch history buffer in\nwhich the highest priority thread uses the most significant\n2 bits to change the prediction state while the background thread\nuses only the least significant 2 bits. The second scheme uses\nthe shared 2-bit branch history buffer that implements integer\nupdates for the highest priority thread but fractional updates\nfor the background thread in order to achieve relatively higher\nprediction accuracy in the highest priority thread. The low cost\nnature of these two schemes, particularly in the second scheme,\nmakes them attractive with moderate improvement in the\nperformance of the highest priority thread.\n",
        "affiliation": "ARM Ltd",
        "title": "{L}ow-cost {T}echniques for {R}educing {B}ranch {C}ontext {P}ollution in a {S}oft\n{R}ealtime {E}mbedded {M}ultithreaded {P}rocessor",
        "author": "Emre {\\\"O}zer and\nAlastair Reid and\nStuart Biles",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/sbac-pad/OzerRB07",
        "file": "SBACPAD07.pdf",
        "png": "SBACPAD07.png",
        "ar_file": "SBAC_PAD_07",
        "ar_title": "Low-cost Techniques for Reducing Branch Context Pollution in a Soft Realtime Embedded Multithreaded Processor"
    },
    {
        "ar_shortname": "SiPS 06",
        "doi": "10.1109/SIPS.2006.352549",
        "year": "2006",
        "publisher": "IEEE",
        "pages": "22--27",
        "location": "Banff, Alberta, Canada",
        "day": "2-4",
        "month": "October",
        "booktitle": "Proceedings of the IEEE Workshop on Signal Processing Systems\n(SiPS 2006)",
        "abstract": "\nSoftware Defined Radio(SDR) is an emerging paradigm for wireless\nterminals, in which the physical layer of communication\nprotocols is implemented in software rather than by ASICs. Many\nof the current and next generation wireless protocols include\nTurbo coding because of its superior performance. However, Turbo\ndecoding is computationally intensive, and its low power\nimplementations have typ- ically been in ASICs. This paper\npresents a case study of algorithm-architecture co-design of\nTurbo decoder for SDR. We present a programmable DSP architecture\nfor SDR that includes a set of architectural features to\naccelerate Turbo decoder computations. We then present a parallel\nwindow scheduling for MAX-Log-MAP component decoder that\nmatches well with the DSP architecture. Finally, we present\na software implementation of Turbo decoder for W-CDMA on the DSP\narchitecture and show that it achieves 2Mbps decoding throughput.\n",
        "affiliation": "ARM Ltd and University of Michigan and Arizona State University",
        "title": "{D}esign and {I}mplementation of {T}urbo {D}ecoders for {S}oftware {D}efined {R}adio",
        "author": "Yuan Lin and\nScott A. Mahlke and\nTrevor N. Mudge and\nChaitali Chakrabarti and\nAlastair Reid and\nKriszti{\\'a}n Flautner",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/sips/LinMMCRF06",
        "file": "lin-sips06.pdf",
        "png": "lin-sips06.png",
        "ar_file": "SiPS_06",
        "ar_title": "Design and Implementation of Turbo Decoders for Software Defined Radio"
    },
    {
        "year": "2006",
        "abstract": "\nHigh-throughput, low-power Software Defined Radio(SDR)\nsolutions require multi-core SIMD DSP processors to meet\nreal-time performance requirements. Given the difficulty in\nprogramming traditional DSPs, these new multi-core signal\nprocessors provide even greater challenges for programmers and\ncompilers. In this paper, we describe SPEX, a programming\nlanguage which is aimed at narrowing the semantic gap between\nthe description of complex SDR systems and their\nimplementations. SPEX supports three different types of\nprogramming semantics, allowing SDR solutions to be developed\nwith a divide-and-conquer approach. For DSP algorithm\nkernels, SPEX is able to support DSP arithmetics and\nfirst-class vector and matrix variables with sequential\nlanguage semantics. From wireless protocol channels, it is able\nto support sequences of data-processing computations with\ndataflow language semantics. And for protocol systems, it is\nable to support real-time deadlines and concurrent executions\nwith synchronous language semantics. The design choices are\nmotivated by our experience implementing W-CDMA protocol on\na reprogrammable substrate. In the paper, we also briefly\nexplain SPEX\\textquotesingle s compilation strategies.\n",
        "affiliation": "ARM Ltd and University of Michigan",
        "ar_shortname": "SDR 06",
        "location": "Orlando, FL, USA",
        "month": "November",
        "day": "13-17",
        "booktitle": "Software Defined Radio Technical Conference and Product Exposition",
        "title": "S{P}EX: {A} programming language for software defined radio",
        "authors": "Yuan Lin and Robert Mullenix and Mark Woh and Scott Mahlke\nand Trevor Mudge Alastair Reid and Kriszti{\\'a}n Flautner",
        "ENTRYTYPE": "inproceedings",
        "ID": "conf:SDR:LinMW2006",
        "file": "lin-sdr06.pdf",
        "png": "lin-sdr06.png",
        "ar_file": "SDR_06",
        "ar_title": "SPEX: A programming language for software defined radio"
    },
    {
        "ar_shortname": "TECS 05",
        "doi": "10.1145/1113830.1113833",
        "year": "2005",
        "pages": "751--778",
        "number": "4",
        "volume": "4",
        "journal": "ACM Transactions Embedded Computing Systems",
        "abstract": "\nAn important correctness criterion for software running on\nembedded microcontrollers is stack safety: a guarantee that the\ncall stack does not overflow. Our first contribution is a method\nfor statically guaranteeing stack safety of interrupt-driven\nembedded software using an approach based on context-sensitive\ndataflow analysis of object code. We have implemented a prototype\nstack analysis tool that targets software for Atmel AVR\nmicrocontrollers and tested it on embedded applications compiled\nfrom up to 30,000 lines of C. We experimentally validate the\naccuracy of the tool, which runs in under 10 sec on the largest\nprograms that we tested. The second contribution of this paper is\nthe development of two novel ways to reduce stack memory\nrequirements of embedded software.\n",
        "affiliation": "University of Utah",
        "title": "{E}liminating stack overflow by abstract interpretation",
        "author": "John Regehr and\nAlastair Reid and\nKirk Webb",
        "ENTRYTYPE": "article",
        "ID": "DBLP:journals/tecs/RegehrRW05",
        "file": "p751-regehr.pdf",
        "png": "p751-regehr.png",
        "ar_file": "TECS_05",
        "ar_title": "Eliminating stack overflow by abstract interpretation"
    },
    {
        "ar_shortname": "ASPLOS 04",
        "doi": "10.1145/1024393.1024410",
        "year": "2004",
        "publisher": "ACM",
        "pages": "133--143",
        "day": "7-13",
        "month": "October",
        "location": "Boston, MA, USA",
        "booktitle": "Proceedings of the 11th International Conference on Architectural\nSupport for Programming Languages and Operating Systems (ASPLOS\n2004)",
        "acceptance": "14",
        "abstract": "\nEmbedded software must meet conflicting requirements such as be-\ning highly reliable, running on resource-constrained platforms,\nand being developed rapidly. Static program analysis can help\nmeet all of these goals. People developing analyzers for embedded\nobject code face a difficult problem: writing an abstract version\nof each instruction in the target architecture(s). This is\ncurrently done by hand, resulting in abstract operations that are\nboth buggy and imprecise. We have developed Hoist: a novel\nsystem that solves these problems by automatically constructing\nabstract operations using a microprocessor (or simulator) as its\nown specification. With almost no input from a human, Hoist\ngenerates a collection of C functions that are ready to be\nlinked into an abstract interpreter. We demonstrate that Hoist\ngenerates abstract operations that are correct, having been\nextensively tested, sufficiently fast, and substantially more\nprecise than manually written abstract operations. Hoist is\ncurrently limited to eight-bit machines due to costs exponential\nin the word size of the target architecture. It is essential to\nbe able to analyze software running on these small processors:\nthey are important and ubiquitous, with many embedded and\nsafety-critical systems being based on them.\n",
        "affiliation": "University of Utah",
        "title": "H{O}IS{T}: a system for automatically deriving static analyzers for\nembedded systems",
        "editor": "Shubu Mukherjee and\nKathryn S. McKinley",
        "author": "John Regehr and\nAlastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/asplos/RegehrR04",
        "file": "p021-regehr.pdf",
        "png": "p021-regehr.png",
        "ar_file": "ASPLOS_04",
        "ar_title": "HOIST: a system for automatically deriving static analyzers for embedded systems"
    },
    {
        "year": "2003",
        "day": "17",
        "month": "March",
        "location": "Boston, MA, USA",
        "ar_shortname": "ACP4IS 03",
        "booktitle": "Proceedings of the Second AOSD Workshop on Aspects,\nComponents, and Patterns for Infrastructure Software (ACP4IS)",
        "abstract": "\nWe have developed task scheduler logic (TSL) to automate\nreasoning about scheduling and concurrency in systems software.\nTSL can detect race conditions and other errors as well as\nsupporting lock inference: the derivation of an appropriate\nlock implementation for each critical section in a system. Lock\ninference solves a number of problems in creating flexible,\nreliable, and efficient systems software. TSL is based on\na notion of asymmetrical preemption relations and it exploits\nthe hierarchical inheritance of scheduling properties that is\ncommon in systems software.\n",
        "affiliation": "University of Utah",
        "author": "John Regehr and Alastair Reid",
        "title": "{L}ock inference for systems software",
        "ENTRYTYPE": "inproceedings",
        "ID": "tsl-acp4is2003",
        "file": "tsl-acp4is.pdf",
        "png": "tsl-acp4is.png",
        "ar_file": "ACP4IS_03",
        "ar_title": "Lock inference for systems software"
    },
    {
        "ar_shortname": "EMSOFT 03",
        "doi": "10.1007/978-3-540-45212-6\\_20",
        "year": "2003",
        "publisher": "Springer",
        "pages": "306--322",
        "volume": "2855",
        "series": "Lecture Notes in Computer Science",
        "day": "13-15",
        "month": "October",
        "location": "Philadelphia, PA, USA",
        "booktitle": "Embedded Software, Third International Conference (EMSOFT 2003)",
        "abstract": "\nAn important correctness criterion for software running on\nembedded microcontrollers is stack safety: a guarantee that the\ncall stack does not overflow. We address two aspects of the\nproblem of creating stack-safe embedded software that also makes\nefficient use of memory: statically bounding worst-case stack\ndepth, and automatically reducing stack memory requirements. Our\nfirst contribution is a method for statically guaranteeing stack\nsafety by performing whole-program analysis, using an approach\nbased on context-sensitive abstract interpretation of machine\ncode. Abstract interpretation permits our analysis to accurately\nmodel when interrupts are enabled and disabled, which is\nessential for accurately bounding the stack depth of typical\nembedded systems. We have implemented a stack analysis tool that\ntargets Atmel AVR microcontrollers, and tested it on embedded\napplications compiled from up to 30,000 lines of C. We\nexperimentally validate the accuracy of the tool, which runs in\na few seconds on the largest programs that we tested. The second\ncontribution of this paper is a novel framework for automatically\nreducing stack memory requirements. We show that goal-directed\nglobal function inlining can be used to reduce the stack memory\nrequirements of component-based embedded software, on average, to\n40\\% of the requirement of a system compiled without inlining, and\nto 68\\% of the requirement of a system compiled with aggressive\nwhole-program inlining that is not directed towards reducing\nstack usage.\n",
        "affiliation": "University of Utah",
        "title": "{E}liminating {S}tack {O}verflow by {A}bstract {I}nterpretation",
        "editor": "Rajeev Alur and\nInsup Lee",
        "author": "John Regehr and\nAlastair Reid and\nKirk Webb",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/emsoft/RegehrRW03",
        "file": "emsoft03-preprint.pdf",
        "png": "emsoft03-preprint.png",
        "ar_file": "EMSOFT_03",
        "ar_title": "Eliminating Stack Overflow by Abstract Interpretation"
    },
    {
        "ar_shortname": "RTSS 03",
        "doi": "10.1109/REAL.2003.1253251",
        "year": "2003",
        "publisher": "IEEE Computer Society",
        "pages": "25--36",
        "location": "Cancun, Mexico",
        "month": "December",
        "day": "3-5",
        "booktitle": "Proceedings of the 24th IEEE Real-Time Systems Symposium (RTSS 2003)",
        "abstract": "\nWe have developed a new way to look at real-time and embedded\nsoftware: as a collection of execution environments created by\na hierarchy of schedulers. Common schedulers include those that run\ninterrupts, bottom-half handlers, threads, and events. We have\ncreated algorithms for deriving response times, scheduling overheads,\nand blocking terms for tasks in systems containing multiple execution\nenvironments. We have also created task scheduler logic, a formalism\nthat permits checking systems for race conditions and other errors.\nConcurrency analysis of low-level software is challenging because\nthere are typically several kinds of locks, such as thread mutexes\nand disabling interrupts, and groups of cooperating tasks may need to\nacquire some, all, or none of the available types of locks to create\ncorrect software. Our high level goal is to create systems that are\nevolvable: they are easier to modify in response to changing\nrequirements than are systems created using traditional techniques.\nWe have applied our approach to two case studies in evolving software\nfor networked sensor nodes.\n",
        "affiliation": "University of Utah",
        "title": "{E}volving real-time systems using hierarchical scheduling and concurrency\nanalysis",
        "author": "John Regehr and\nAlastair Reid and\nKirk Webb and\nMichael A. Parker and\nJay Lepreau",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/rtss/RegehrRWPL03",
        "file": "rtss03-preprint.pdf",
        "png": "rtss03-preprint.png",
        "ar_file": "RTSS_03",
        "ar_title": "Evolving real-time systems using hierarchical scheduling and concurrency analysis"
    },
    {
        "url": "http://web.archive.org/web/20180702051235/www.cse.unsw.edu.au/\\textasciitilde chak/haskell/ffi/",
        "year": "2003",
        "author": "\nManuel Chakravarty\nand Sigbjorn Finne\nand Fergus Henderson\nand Marcin Kowalczyk\nand Daan Leijen\nand Simon Marlow\nand Erik Meijer\nand Sven Panne\nand Simon Peyton Jones\nand Alastair Reid\nand Malcolm Wallace\nand Michael Weber\n",
        "ar_shortname": "Haskell FFI",
        "title": "{T}he {H}askell 98 {F}oreign {F}unction {I}nterface 1.0: {A}n {A}ddendum to the {H}askell 98 {R}eport",
        "ENTRYTYPE": "article",
        "ID": "report:haskellffi:chakravarty2003",
        "link": "http://web.archive.org/web/20180702051235/www.cse.unsw.edu.au/\\textasciitilde chak/haskell/ffi/",
        "file": "ffi.pdf",
        "png": "ffi.png",
        "ar_file": "Haskell_FFI",
        "ar_title": "The Haskell 98 Foreign Function Interface 1.0: An Addendum to the Haskell 98 Report"
    },
    {
        "ar_shortname": "ICSE 02",
        "doi": "10.1145/581339.581367",
        "year": "2002",
        "publisher": "ACM",
        "pages": "208--218",
        "location": "Orlando, Florida, USA",
        "month": "May",
        "day": "19-25",
        "booktitle": "Proceedings of the 24th International Conference on Software Engineering\n(ICSE 2002)",
        "abstract": "\nDesign patterns are a valuable mechanism for emphasizing\nstructure, capturing design expertise, and facilitating restructuring of\nsoftware systems. Patterns are typically applied in the context of an\nobject-oriented language and are implemented so that the pattern\nparticipants correspond to object instances that are created and\nconnected at run-time. This paper describes a complementary\nrealization of design patterns, in which many pattern participants\ncorrespond to statically instantiated and connected components.Our\napproach separates the static parts of the software design from the\ndynamic parts of the system behavior. This separation makes the\nsoftware design more amenable to analysis, thus enabling more\neffective and domain-specific detection of system design errors,\nprediction of run-time behavior, and more effective optimization. This\ntechnique is applicable to imperative, functional, and\nobject-oriented languages: we have extended C, Scheme, and Java with\nour component model. In this paper, we illustrate our approach in the\ncontext of the OSKit, a collection of operating system components\nwritten in C.\n",
        "affiliation": "University of Utah",
        "acceptance": "15",
        "title": "{S}tatic and dynamic structure in design patterns",
        "editor": "Will Tracz and\nMichal Young and\nJeff Magee",
        "author": "Eric Eide and\nAlastair Reid and\nJohn Regehr and\nJay Lepreau",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/icse/EideRRL02",
        "file": "knit-icse02.pdf",
        "png": "knit-icse02.png",
        "ar_file": "ICSE_02",
        "ar_title": "Static and dynamic structure in design patterns"
    },
    {
        "year": "2001",
        "month": "May",
        "location": "Toronto, Ontario, Canada",
        "booktitle": "Workshop on Advanced Separation of Concerns in Software Engineering",
        "abstract": "\nKnit is a new component specification and linking language. It\nwas initially designed for low-level systems software, which\nrequires especially flexible components with especially\nwell-defined interfaces. For example, threads and virtual memory\nare typically implemented by components within the system,\ninstead of being supplied by some execution environment.\nConsequently, components used to construct the system must expose\ninteractions with threads and memory. The component composition\ntool must then check the resulting system for correctness, and\nweave the components together to achieve reasonable performance.\n\nComponent composition with Knit thus acts like aspect weaving: component\ninterfaces determine the \\textasciigrave \\textasciigrave join points\\textquotesingle \\textquotesingle  for weaving, while components (some of\nwhich may be automatically generated) implement aspects. Knit is not limited to\nthe construction of low-level software, and to the degree that a set of\ncomponents exposes fine-grained relationships, Knit provides the benefits\nof aspect-oriented programming within its component model.\n",
        "affiliation": "University of Utah",
        "ar_shortname": "ASPSE 01",
        "title": "{A}spect {W}eaving as {C}omponent {K}nitting: {S}eparating {C}oncerns with {K}nit",
        "author": "Eric Eide and Alastair Reid and Matthew Flatt and Jay Lepreau",
        "ENTRYTYPE": "inproceedings",
        "ID": "EEide01Aspect",
        "file": "knit-icse01-wasc.pdf",
        "png": "knit-icse01-wasc.png",
        "ar_file": "ASPSE_01",
        "ar_title": "Aspect Weaving as Component Knitting: Separating Concerns with Knit"
    },
    {
        "ar_shortname": "PADL 01",
        "doi": "10.1007/3-540-45241-9\\_21",
        "year": "2001",
        "publisher": "Springer",
        "pages": "304--321",
        "volume": "1990",
        "series": "Lecture Notes in Computer Science",
        "day": "11-12",
        "month": "March",
        "location": "Las Vegas, Nevada, USA",
        "booktitle": "Practical Aspects of Declarative Languages, Third International Symposium\n(PADL 2001)",
        "abstract": "\nFunctional programming languages are not generally associated\nwith computationally intensive tasks such as computer vision. We show\nthat a declarative programming language like Haskell is effective for\ndescribing complex visual tracking systems. We have taken an existing\nC++ library for computer vision, called XVision, and used it to build\nFVision (pronounced \\textasciigrave \\textasciigrave fission\\textquotesingle \\textquotesingle ), a library of Haskell types and\nfunctions that provides a high-level interface to the lower-level\nXVision code. Using functional abstractions, users of FVision can\nbuild and test new visual tracking systems rapidly and reliably. The\nuse of Haskell does not degrade system performance: computations are\ndominated by low-level calculations expressed in C++ while the\nHaskell \\textasciigrave \\textasciigrave glue code\\textquotesingle \\textquotesingle  has a negligible impact on performance.\n\nFVision is built using functional reactive programming (FRP) to\nexpress interaction in a purely functional manner. The resulting\nsystem demonstrates the viability of mixed-language programming:\nvisual tracking programs continue to spend most of their time\nexecuting low-level image-processing code, while Haskell\\textquotesingle s advanced\nfeatures allow us to develop and test systems quickly and with\nconfidence. In this paper, we demonstrate the use of Haskell and FRP\nto express many basic abstractions of visual tracking.\n",
        "affiliation": "Yale University",
        "title": "F{V}ision: {A} Declarative {L}anguage for {V}isual {T}racking",
        "editor": "I. V. Ramakrishnan",
        "author": "John Peterson and\nPaul Hudak and\nAlastair Reid and\nGregory D. Hager",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/padl/PetersonHRH01",
        "file": "fvision-padl01-2.pdf",
        "png": "fvision-padl01-2.png",
        "ar_file": "PADL_01",
        "ar_title": "FVision: A Declarative Language for Visual Tracking"
    },
    {
        "year": "2001",
        "ar_shortname": "GLib 01",
        "location": "New Haven, CT, USA",
        "affiliation": "Yale University",
        "title": "{T}he {H}ugs {G}raphics {L}ibrary ({V}ersion 2.0)",
        "author": "Alastair Reid",
        "ENTRYTYPE": "misc",
        "ID": "hugsgraphics2001",
        "file": "hugsgraphics.pdf",
        "png": "hugsgraphics.png",
        "ar_file": "GLib_01",
        "ar_title": "The Hugs Graphics Library (Version 2.0)"
    },
    {
        "url": "http://dl.acm.org/citation.cfm?id=1251253",
        "ar_shortname": "OSDI 00",
        "year": "2000",
        "publisher": "USENIX Association",
        "pages": "347--360",
        "day": "23-25",
        "month": "October",
        "location": "San Diego, California, USA",
        "booktitle": "4th Symposium on Operating System Design and Implementation (OSDI 2000)",
        "abstract": "\nKnit is a new component definition and linking language for\nsystems code. Knit helps make C code more understandable and reusable by\nthird parties, helps eliminate much of the performance overhead of\ncomponentization, detects subtle errors in component composition that\ncannot be caught with normal component type systems, and provides\na foundation for developing future analyses over C-based components,\nsuch as cross-component optimization. The language is especially designed\nfor use with component kits, where standard linking tools provide\ninadequate support for component configuration. In particular, we\ndeveloped Knit for use with the OSKit, a large collection of\ncomponents for building low-level systems. However, Knit is\nnot OSKit-specific, and we have implemented parts of the\nClick modular router in terms of Knit components to\nillustrate the expressiveness and flexibility of our\nlanguage. This paper provides an overview of the Knit\nlanguage and its applications.\n",
        "affiliation": "University of Utah",
        "title": "{K}nit: {C}omponent {C}omposition for {S}ystems {S}oftware",
        "editor": "Michael B. Jones and\nM. Frans Kaashoek",
        "author": "Alastair Reid and\nMatthew Flatt and\nLeigh Stoller and\nJay Lepreau and\nEric Eide",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/osdi/ReidFSLE00",
        "link": "http://dl.acm.org/citation.cfm?id=1251253",
        "file": "knit-osdi00.pdf",
        "png": "knit-osdi00.png",
        "ar_file": "OSDI_00",
        "ar_title": "Knit: Component Composition for Systems Software"
    },
    {
        "ar_shortname": "ICSE 99",
        "doi": "10.1109/icse.1999.841038",
        "year": "1999",
        "publisher": "ACM",
        "pages": "484--493",
        "day": "16-22",
        "month": "May",
        "location": "Los Angeles, CA, USA",
        "booktitle": "Proceedings of the 1999 International Conference on Software Engineering\n(ICSE \\textquotesingle 99)",
        "abstract": "\nWe describe the transformation of XVision, a large library of\nC++ code for real-time vision processing, into FVision (pronounced\n\\textasciigrave \\textasciigrave fission\\textquotesingle \\textquotesingle ), a fully-featured domain-specific language embedded\nin Haskell. The resulting prototype system substantiates the claims\nof increased modularity, effective code reuse, and rapid prototyping\nthat characterize the DSL approach to system design. It also\nillustrates the need for judicious interface design: relegating\ncomputationally expensive tasks to XVision (pre-existing C++\ncomponents), and leaving modular compositional tasks to\nFVision (Haskell). At the same time, our experience demonstrates how\nHaskell\\textquotesingle s advanced language features (specifically parametric\npolymorphism, lazy evaluation, higher order functions and\nautomatic storage reclamation) permit a rapid DSL design that\nis itself highly modular and easily modified. Overall, the resulting\nhybrid system exceeded our expectations: visual tracking programs\ncontinue to spend most of their time executing low level\nimage-processing code, while Haskell\\textquotesingle s advanced features allow us to\nquickly develop and test small prototype systems within a matter of\na few days and to develop realistic applications within a few weeks.\n",
        "affiliation": "Yale University",
        "acceptance": "19",
        "title": "{P}rototyping {R}eal-{T}ime {V}ision {S}ystems: {A}n {E}xperiment in {D}SL {D}esign",
        "editor": "Barry W. Boehm and\nDavid Garlan and\nJeff Kramer",
        "author": "Alastair Reid and\nJohn Peterson and\nGregory D. Hager and\nPaul Hudak",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/icse/ReidPHH99",
        "file": "fvision-icse99-2.pdf",
        "png": "fvision-icse99-2.png",
        "ar_file": "ICSE_99",
        "ar_title": "Prototyping Real-Time Vision Systems: An Experiment in DSL Design"
    },
    {
        "ar_shortname": "PLDI 99",
        "doi": "10.1145/301618.301637",
        "year": "1999",
        "publisher": "ACM",
        "pages": "25--36",
        "day": "1-4",
        "month": "May",
        "location": "Atlanta, Georgia, USA",
        "booktitle": "Proceedings of the 1999 ACM SIGPLAN Conference on Programming\nLanguage Design and Implementation (PLDI \\textquotesingle 99)",
        "abstract": "\nSome modern superscalar microprocessors provide only imprecise\nexceptions. That is, they do not guarantee to report the same exception\nthat would be encountered by a straightforward sequential execution\nof the program. In exchange, they offer increased performance or\ndecreased area (which amount to much the same thing).\n\nThis performance/precision tradeoff has not so far been much explored at\nthe programming language level. In this paper we propose a design for\nimprecise exceptions in the lazy functional programming language Haskell.\nWe discuss various simpler designs, and conclude that imprecision is\nessential if the language is still to enjoy its current rich algebra of\ntransformations. We sketch a precise semantics for the language extended\nwith exceptions.\n\nFrom the functional programming point of view, the paper shows how to\nextend Haskell with exceptions without crippling the language or its\ncompilers. From the point of view of the wider programming language\ncommunity, we pose the question of whether precision and performance\ncan be traded off in other languages too.  ",
        "affiliation": "Yale University and Microsoft Research and Cambridge University\nand University of Melbourne",
        "acceptance": "20",
        "title": "{A} Semantics for {I}mprecise {E}xceptions",
        "editor": "Barbara G. Ryder and\nBenjamin G. Zorn",
        "author": "Simon L. Peyton Jones and\nAlastair Reid and\nFergus Henderson and\nC. A. R. Hoare and\nSimon Marlow",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/pldi/JonesRHHM99",
        "file": "except.pdf",
        "png": "except.png",
        "ar_file": "PLDI_99",
        "ar_title": "A Semantics for Imprecise Exceptions"
    },
    {
        "url": "https://www.haskell.org/definition/",
        "year": "1999",
        "author": "\nSimon Peyton Jones\nand Lennart Augustsson\nand Dave Barton\nand Brian Boutel\nand Warren Burton\nand Joseph Fasel\nand Kevin Hammond\nand Ralf Hinze\nand Paul Hudak\nand John Hughes\nand Thomas Johnsson\nand Mark Jones\nand John Launchbury\nand Erik Meijer\nand John Peterson\nand Alastair Reid\nand Colin Runciman\nand Philip Wadler\n",
        "ar_shortname": "Haskell Report",
        "title": "{H}askell 98: {A} non-strict, purely functional language",
        "ENTRYTYPE": "misc",
        "ID": "report:haskell98report:jones1999",
        "link": "https://www.haskell.org/definition/",
        "file": "haskell98-report.pdf",
        "png": "haskell98-report.png",
        "ar_file": "Haskell_Report",
        "ar_title": "Haskell 98: A non-strict, purely functional language"
    },
    {
        "url": "https://www.haskell.org/definition/",
        "year": "1999",
        "author": "\nSimon Peyton Jones\nand Lennart Augustsson\nand Dave Barton\nand Brian Boutel\nand Warren Burton\nand Joseph Fasel\nand Kevin Hammond\nand Ralf Hinze\nand Paul Hudak\nand John Hughes\nand Thomas Johnsson\nand Mark Jones\nand John Launchbury\nand Erik Meijer\nand John Peterson\nand Alastair Reid\nand Colin Runciman\nand Philip Wadler\n",
        "ar_shortname": "Haskell Lib",
        "title": "{S}tandard {L}ibraries for the {H}askell 98 {P}rogramming {L}anguage",
        "ENTRYTYPE": "misc",
        "ID": "report:haskell98libraries:jones1999",
        "link": "https://www.haskell.org/definition/",
        "file": "haskell98-library.pdf",
        "png": "haskell98-library.png",
        "ar_file": "Haskell_Lib",
        "ar_title": "Standard Libraries for the Haskell 98 Programming Language"
    },
    {
        "ar_shortname": "IFL 98",
        "doi": "10.1007/3-540-48515-5\\_12",
        "year": "1998",
        "publisher": "Springer",
        "pages": "186--199",
        "volume": "1595",
        "series": "Lecture Notes in Computer Science",
        "day": "9-11",
        "month": "September",
        "location": "London, UK",
        "booktitle": "Implementation of Functional Languages, 10th International Workshop\n(IFL\\textquotesingle 98) Selected Papers",
        "abstract": "\nInterrupt handling is a tricky business in lazy functional\nlanguages: we have to make sure that thunks that are being evaluated can\nbe halted and later restarted if and when they are required. This is\na particular problem for implementations which use black-holing.\nBlack-Holing deliberately makes it impossible to revert such thunks\nto their original state to avoid a serious space leak. Interactive\nHaskell implementations such as Hugs and hbi catch interrupts and\navoid the problem by omitting or disabling black-holing. Batch mode\nHaskell implementations such as HBC and the Glasgow Haskell Compiler\n(GHC) avoid this problem by disabling black-holing or by providing no\nway to catch interrupts. This paper describes a modification to GHC\\textquotesingle s\nabstract machine (the Spineless Tagless G-Machine) which\nsimultaneously supports both interrupts and black-holing.",
        "affiliation": "Yale University",
        "title": "{P}utting the {S}pine {B}ack in the {S}pineless {T}agless {G}-Machine: {A}n {I}mplementation\nof {R}esumable {B}lack-{H}oles",
        "editor": "Kevin Hammond and\nAntony J. T. Davie and\nChris Clack",
        "author": "Alastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/ifl/Reid98",
        "file": "spine-ifl98.pdf",
        "png": "spine-ifl98.png",
        "ar_file": "IFL_98",
        "ar_title": "Putting the Spine Back in the Spineless Tagless G-Machine: An Implementation of Resumable Black-Holes"
    },
    {
        "year": "1998",
        "month": "August",
        "location": "New Haven, CT, USA",
        "booktitle": "Yale University Research Report YALE/DCS/RR-1178",
        "abstract": "\nUsing a language without exception handling is like driving\na car with no brakes and no seatbelt --- things work fine until\nsomething goes wrong. You also learn to drive rather carefully.\nThis paper describes an exception handling extension to the Haskell\nlazy functional language. The implementation turned out to be very\neasy but we had problems finding a viable semantics for our system.\nThe resulting semantics is a compromise between theoretical beauty\nand practical utility.\n",
        "affiliation": "Yale University",
        "ar_shortname": "Exceptions",
        "title": "{H}andling {E}xceptions in {H}askell",
        "author": "Alastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "Reid98exceptions",
        "file": "exceptions98.pdf",
        "png": "exceptions98.png",
        "ar_file": "Exceptions",
        "ar_title": "Handling Exceptions in Haskell"
    },
    {
        "year": "1998",
        "title": "{D}esigning the {S}tandard {H}askell {L}ibraries",
        "affiliation": "Yale University",
        "ar_shortname": "StdLib 98",
        "author": "Alastair Reid and John Peterson",
        "ENTRYTYPE": "misc",
        "ID": "Reid98haskelllibraries",
        "file": "libraries.pdf",
        "png": "libraries.png",
        "ar_file": "StdLib_98",
        "ar_title": "Designing the Standard Haskell Libraries"
    },
    {
        "year": "1997",
        "month": "June",
        "location": "Amsterdam, Netherlands",
        "booktitle": "Proceedings of the Haskell Workshop",
        "affiliation": "Yale University and Oregon Graduate Institute",
        "title": "{G}reen {C}ard: a foreign-language interface for {H}askell",
        "ar_shortname": "Haskell 97",
        "author": "Simon Peyton Jones and Thomas Nordin and Alastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "greencard1997",
        "file": "green-card.pdf",
        "png": "green-card.png",
        "ar_file": "Haskell_97",
        "ar_title": "Green Card: a foreign-language interface for Haskell"
    },
    {
        "url": "https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf",
        "year": "1995",
        "location": "Portland, Oregon, USA",
        "booktitle": "Proceedings of the Haskell Workshop 1995,\nYale University Research Report YALE/DCS/RR-1075",
        "affiliation": "Yale University",
        "title": "{A}dding {R}ecords to {H}askell",
        "ar_shortname": "Haskell 95a",
        "author": "John Peterson and Alastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "Peterson95addingrecords",
        "link": "https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf",
        "file": "records.pdf",
        "png": "records.png",
        "ar_file": "Haskell_95a",
        "ar_title": "Adding Records to Haskell"
    },
    {
        "url": "https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf",
        "page": "69-81",
        "year": "1995",
        "location": "Portland, Oregon, USA",
        "booktitle": "Proceedings of the Haskell Workshop 1995,\nYale University Research Report YALE/DCS/RR-1075",
        "affiliation": "Yale University",
        "title": "{A} Proposal for the {S}tandard {H}askell {L}ibraries",
        "ar_shortname": "Haskell 95b",
        "author": "Alastair Reid and John Peterson",
        "ENTRYTYPE": "inproceedings",
        "ID": "Reid95haskelllibraries",
        "link": "https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf",
        "file": "HW1995-Proceedings.pdf",
        "png": "HW1995-Proceedings.png",
        "ar_file": "Haskell_95b",
        "ar_title": "A Proposal for the Standard Haskell Libraries"
    },
    {
        "year": "1994",
        "month": "September",
        "day": "12\\textendash 14",
        "location": "Ayr, Scotland",
        "booktitle": "Draft Proceedings of the Glasgow Functional Programming Workshop",
        "affiliation": "University of Glasgow",
        "title": "{M}alloc {P}ointers and {S}table {P}ointers: {I}mproving {H}askell\\textquotesingle s {F}oreign {L}anguage {I}nterface",
        "ar_shortname": "GFPW 94",
        "author": "Alastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "Reid94mallocpointers",
        "file": "malloc.pdf",
        "png": "malloc.png",
        "ar_file": "GFPW_94",
        "ar_title": "Malloc Pointers and Stable Pointers: Improving Haskell's Foreign Language Interface"
    },
    {
        "ar_shortname": "GFPW 93",
        "doi": "10.1007/978-1-4471-3236-3\\_18",
        "isbn": "978-1-4471-3236-3",
        "pages": "222--235",
        "address": "London",
        "publisher": "Springer London",
        "year": "1993",
        "month": "July",
        "day": "5-7",
        "location": "Ayr, Scotland",
        "booktitle": "Proceedings of the 1993 Glasgow Workshop on Functional Programming",
        "abstract": "\nCarlsson and Hallgren describe the implementation of a set of\n\"functional widgets\" (Fudgets): components for programming graphical\nuser interfaces under the X window system using the non-strict\nfunctional programming language Haskell.\nWe describe an alternative implementation based on existing\nwidget sets (currently Openlook and Motif).\nOur purpose is twofold: to show that the Fudgets approach can be\napplied to existing widget sets; and to discuss problems experienced\nwith Fudgets during an industrial case study.\n",
        "affiliation": "University of Glasgow",
        "title": "{I}mplementing {F}udgets with {S}tandard {W}idget {S}ets",
        "editor": "John T. O\\textquotesingle Donnell and Kevin Hammond",
        "author": "Alastair Reid and Satnam Singh",
        "ENTRYTYPE": "inbook",
        "ID": "Reid1993",
        "ar_file": "GFPW_93",
        "ar_title": "Implementing Fudgets with Standard Widget Sets"
    },
    {
        "year": "1993",
        "ar_shortname": "MSc 93",
        "location": "Glasgow, Scotland",
        "school": "Glasgow School of Computing Science",
        "abstract": "\nAll formal specifiers face the danger of overspecification:\naccidentally writing an overly restrictive specification.\nThis problem is particularly acute for axiomatic specifications\nbecause it is so easy to write axioms that hold for some of the\nintended implementations but not for all of them (or, rather, it\nis hard not to write overly strong axioms).\n\nOne of the best developed ways of recovering some of these implementations\nwhich do not literally satisfy the specification is to apply a \\textasciigrave \\textasciigrave behavioural\nabstraction operator\\textquotesingle \\textquotesingle  to a specification: adding in those implementations\nwhich have the same \\textasciigrave \\textasciigrave behaviour\\textquotesingle \\textquotesingle  as an implementation which does satisfy\nthe specification.\n\nIn two recent papers, Broy and Wirsing propose an alternative (and apparently\nsimpler) approach which they call \\textasciigrave \\textasciigrave ultraloose specification.\\textquotesingle \\textquotesingle   This approach\nis based on a particular style of writing axioms which avoids certain forms\nof overspecification.\n\nAn important, unanswered question is \\textasciigrave \\textasciigrave How does the ultraloose approach relate\nto other solutions?\\textquotesingle \\textquotesingle  The major achievement of this thesis is a proof that the\nultraloose approach is semantically equivalent to the use of the \\textasciigrave \\textasciigrave behavioural\nabstraction operator.\\textquotesingle \\textquotesingle   This result is rather surprising in the light of a result\nby Schoett which seems to say that such a result is impossible.\n",
        "affiliation": "University of Glasgow",
        "title": "{A} Precise {S}emantics for {U}ltraloose {S}pecifications",
        "author": "Alastair Reid",
        "ENTRYTYPE": "mastersthesis",
        "ID": "ReidThesis93",
        "file": "ReidThesis93.pdf",
        "png": "ReidThesis93.png",
        "ar_file": "MSc_93",
        "ar_title": "A Precise Semantics for Ultraloose Specifications"
    },
    {
        "year": "1989",
        "publisher": "Springer",
        "pages": "170--181",
        "series": "Workshops in Computing",
        "location": "Fraserburgh, Scotland, UK",
        "month": "August",
        "day": "21-23",
        "booktitle": "Proceedings of the 1989 Glasgow Workshop on Functional Programming",
        "abstract": "\nThe design (as opposed to the choice and use) of data structures has\nbeen the subject of relatively little study in the context of formal methods.\nIn this paper, we introduce our ideas on how data structures are designed.",
        "affiliation": "University of Glasgow",
        "title": "{D}esigning {D}ata {S}tructures",
        "ar_shortname": "GFPW 89",
        "editor": "Kei Davis and\nJohn Hughes",
        "author": "Alastair Reid",
        "ENTRYTYPE": "inproceedings",
        "ID": "DBLP:conf/fp/Reid89",
        "file": "designing.pdf",
        "png": "designing.png",
        "ar_file": "GFPW_89",
        "ar_title": "Designing Data Structures"
    }
]
